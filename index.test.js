import assert from 'node:assert';
import { BigNumber } from './index.js';

console.log('Testing ArbitraryDecimal, simple cases...');
assert.strictEqual(
  new BigNumber(
    '1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890').toString(),
  '1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890');

assert.strictEqual(
  new BigNumber('1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890').add(new BigNumber('1')).toString(),
  '1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567891');

assert.strictEqual(
  new BigNumber('1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890').subtract(new BigNumber('1')).toString(),
  '1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567889');


console.log('Testing decimal cases...');
// 1. Create arbitrary decimals
const num1 = new BigNumber("123.456");
const num2 = new BigNumber("78.9");

// 2. Add
const sum = num1.add(num2);
assert.strictEqual(sum.toString(), '202.356');

// 3. Subtract
const difference = num1.subtract(num2);
assert.strictEqual(difference.toString(), '44.556');

// 4. Multiply
const product = num1.multiply(num2);
assert.strictEqual(product.toString(), '9740.6784');

// 5. Divide with precision 1.5647148289
const quotient = num1.divide(num2, 5); // up to 5 decimal places
assert.strictEqual(quotient.toString(), '1.56471');


const quotient2 = num1.divide(num2, 10); // up to 10 decimal places
assert.strictEqual(quotient2.toString(), '1.5647148289');

const pow = num1.pow(new BigNumber('2'));
assert.strictEqual(pow.toString(), '15241.383936');
const start = performance.now();
const ln2 = BigNumber.ln2(1000);
const end = performance.now();
const time = end - start;
console.log(`Time to compute ln2 first time: ${time}ms`);
const ln2Actual1000 = '0.693147180559945309417232121458176' +
 '568075500134360255254120680009493393621969694715605863326'+
 '9964186875420014810205706857336855202357581305570326707516'+ 
 '35075961930727570828371435190307038623891673471123350115364'+
 '497955239120475172681574932065155524734139525882950453007095'+
 '326366642654104239157814952043740430385500801944170641671518'+
 '644712839968171784546957026271631064546150257207402481637773'+
 '389638550695260668341137273873722928956493547025762652098859'+
 '693201965058554764703306793654432547632744951250406069438147'+
 '104689946506220167720424524529612687946546193165174681392672'+
 '504103802546259656869144192871608293803172714367782654877566'+
 '485085674077648451464439940461422603193096735402574446070308'+
 '096085047486638523138181676751438667476647890881437141985494'+
 '231519973548803751658612753529166100071053558249879414729509'+
 '293113897155998205654392871700072180857610252368892132449713'+
 '893203784393530887748259701715591070882368362758984258918535'+
 '302436342143670611892367891923723146723217205340164925687274'+
 '7782344535348'
assert.strictEqual(ln2.toString(), ln2Actual1000);
const start2 = performance.now();
const ln2_second = BigNumber.ln2(1000);
const end2 = performance.now();
const time2 = end2 - start2;
console.log(`Time to compute ln2 second time: ${time2}ms`);
assert.strictEqual(ln2_second.toString(), ln2.toString());
// Second one should be way faster
assert(time2 < time);

const truePi1000 = '3.14159265358979323846264338327950288419716' +
 '93993751058209749445923078164062862089986280348253421170679821' +
 '48086513282306647093844609550582231725359408128481117450284102' +
 '70193852110555964462294895493038196442881097566593344612847564' +
 '82337867831652712019091456485669234603486104543266482133936072' +
 '60249141273724587006606315588174881520920962829254091715364367' +
 '89259036001133053054882046652138414695194151160943305727036575' +
 '95919530921861173819326117931051185480744623799627495673518857' +
 '52724891227938183011949129833673362440656643086021394946395224' +
 '73719070217986094370277053921717629317675238467481846766940513' +
 '20005681271452635608277857713427577896091736371787214684409012' +
 '24953430146549585371050792279689258923542019956112129021960864' +
 '03441815981362977477130996051870721134999999837297804995105973' +
 '17328160963185950244594553469083026425223082533446850352619311' +
 '88171010003137838752886587533208381420617177669147303598253490' +
 '42875546873115956286388235378759375195778185778053217122680661' +
 '30019278766111959092164201989';
 const startPi = performance.now();
 const pi = BigNumber.pi(1000);
 const endPi = performance.now();
const timePi = endPi - startPi;
console.log(`Time to compute 1000 digits of pi: ${timePi}ms`);
assert.strictEqual(pi.toString(), truePi1000.toString());
const startPi2 = performance.now();
const pi2 = BigNumber.pi(1000);
const endPi2 = performance.now();
const timePi2 = endPi2 - startPi2;
console.log(`Time to compute 1000 digits of pi second time: ${timePi2}ms`);
assert.strictEqual(pi2.toString(), truePi1000.toString());
// Second one should be way faster
assert(timePi2 < timePi);
console.log('All tests passed!');

const trueE1000 = '2.718281828459045235360287471352662497757247093699' +
 '95957496696762772407663035354759457138217852516642742746639193200305' +
 '99218174135966290435729003342952605956307381323286279434907632338298' +
 '80753195251019011573834187930702154089149934884167509244761460668082' +
 '26480016847741185374234544243710753907774499206955170276183860626133' +
 '13845830007520449338265602976067371132007093287091274437470472306969' +
 '77209310141692836819025515108657463772111252389784425056953696770785' +
 '44996996794686445490598793163688923009879312773617821542499922957635' +
 '14822082698951936680331825288693984964651058209392398294887933203625' +
 '09443117301238197068416140397019837679320683282376464804295311802328' +
 '78250981945581530175671736133206981125099618188159304169035159888851' +
 '93458072738667385894228792284998920868058257492796104841984443634632' +
 '44968487560233624827041978623209002160990235304369941849146314093431' +
 '73814364054625315209618369088870701676839642437814059271456354906130' +
 '31072085103837505101157477041718986106873969655212671546889570350354';

const startE = performance.now();
const e = BigNumber.e(1000);
const endE = performance.now();
const timeE = endE - startE;
console.log(`Time to compute 1000 digits of e: ${timeE}ms`);
assert.strictEqual(e.toString(), trueE1000.toString());

const startE2 = performance.now();
const e2 = BigNumber.e(1000);
const endE2 = performance.now();
const timeE2 = endE2 - startE2;
console.log(`Time to compute 1000 digits of e second time: ${timeE2}ms`);
assert.strictEqual(e2.toString(), trueE1000.toString());
// Second one should be way faster
assert(timeE2 < timeE);



const negativeDecimal = new BigNumber("-78.9");
assert.strictEqual(negativeDecimal.toString(), "-78.9");

const negativeDecimal2 = new BigNumber("-0.9");
assert.strictEqual(negativeDecimal2.toString(), "-0.9");

// Negative decimal with no integer part with addition
assert.strictEqual(negativeDecimal2.add(new BigNumber("1")).toString(), "0.1");

// Negative decimal with no integer part with subtraction
assert.strictEqual(negativeDecimal2.subtract(new BigNumber("1")).toString(), "-1.9");

// Negative decimal with no integer part with multiplication
assert.strictEqual(negativeDecimal2.multiply(new BigNumber("2")).toString(), "-1.8");

// Negative decimal with no integer part with division
assert.strictEqual(negativeDecimal2.divide(new BigNumber("2")).toString(), "-0.45");


const negativeDecimalNoZeros = new BigNumber("-.9");
assert.strictEqual(negativeDecimalNoZeros.toString(), "-0.9");


const decimalNoZeros = new BigNumber(".9");
assert.strictEqual(decimalNoZeros.toString(), "0.9");
